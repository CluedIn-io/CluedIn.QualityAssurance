using System.Text;
using System.Text.Json.Nodes;
using System.Text.Json.Serialization;
using System.Text.Json;
using Microsoft.Extensions.Logging;
using CluedIn.QualityAssurance.Cli.Environments;
using CluedIn.QualityAssurance.Cli.Models.Operations;
using CluedIn.QualityAssurance.Cli.Services.RabbitMQ;
using CluedIn.QualityAssurance.Cli.Services.ResultWriters;
using CluedIn.QualityAssurance.Cli.Services.PostOperationActions;
using System.Text.RegularExpressions;
using JsonCons.JsonPath;
using Spectre.Console;

using SystemEnvironment = System.Environment;
using CluedIn.Core.Data;

namespace CluedIn.QualityAssurance.Cli.Operations.ClueSending;

internal abstract class FileSourceOperation<TOptions> : ClueSendingOperation<TOptions>
    where TOptions : IClueSendingOperationOptions, IFileSourceOperationOptions
{
    protected const string ApplicationJsonContentType = "application/json";
    private const string AutoGeneratedKey = "--auto-generated--";
    private const int MaximumKeyPrefixLength = 50;
    private const int MaximumVocabularyCreationPoll = 10;
    private static readonly TimeSpan DelayAfterVocabularyCreationPoll = TimeSpan.FromSeconds(1);
    private static readonly Regex InvalidEntityTypeNameRegex = new(@"[^a-zA-Z0-9]");
    private static readonly Regex InvalidVocabularyNameRegex = new(@"[^a-zA-Z0-9\.]");
    private static readonly Regex EntityTypeRegex = new(@"{{EntityType\[([a-zA-Z0-9]+)\]}}");
    private static readonly Regex VocabularyRegex = new(@"{{Vocabulary\[([a-zA-Z0-9\.]+)\].(Id|Name)}}");
    private static readonly Regex VocabularyKeyRegex = new(@"{{VocabularyKey\[([a-zA-Z0-9\.]+)\].(Id|Name)}}");
    private static readonly Regex EnvironmentVariableRegex = new(@"{{Env\[([a-zA-Z0-9_]+)\]}}");
    private static readonly Regex RuntimeVariableRegex = new(@"{{Var\[([a-zA-Z0-9_]+)\]}}");

    public FileSourceOperation(
        ILogger<FileSourceOperation<TOptions>> logger,
        IEnvironment testEnvironment,
        IEnumerable<IResultWriter> resultWriters,
        IRabbitMQCompletionChecker rabbitMQCompletionChecker,
        IEnumerable<IPostOperationAction> postOperationActions,
        IHttpClientFactory httpClientFactory)
        : base(logger, testEnvironment, resultWriters, rabbitMQCompletionChecker, postOperationActions, httpClientFactory)
    {
        Logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    protected ICollection<FileSource> FileSources { get; set; } = Array.Empty<FileSource>();

    protected string EntityTypePrefix { get; set; } = string.Empty;

    private ILogger<FileSourceOperation<TOptions>> Logger { get; }

    protected override async Task CreateOperationData(int iterationNumber)
    {
        CreateFileSources(CreateTestId(iterationNumber));
        await base.CreateOperationData(iterationNumber);
    }

    private async Task<(CustomMappingOptions MappingOptions, string json)> GetTestResultCustomizationsAsync(FileSource fileSource)
    {
        if (TestFileHelper.TryGetCustomizationFileStream(fileSource.UploadFilePath, out var customizationFileStream))
        {
            using var reader = new StreamReader(customizationFileStream);
            var json = await reader.ReadToEndAsync();

            var jsonObj = JsonNode.Parse(json);
            var serializeOptions = new JsonSerializerOptions
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                Converters =
                {
                    new JsonStringEnumConverter()
                }
            };

            var customMapping = jsonObj?["customMapping"];
            var requests = customMapping?["requests"]
                ?.AsArray()
                ?.Select((request, index) => {
                    var name = request?["name"]?.Deserialize<string>();
                    var requestBody = request?["request"]?.ToString();
                    var outputVariablesNode = request?["output"];

                    if (name == null)
                    {
                        throw new InvalidOperationException($"Invalid custom request. Name is null for request {index}.");
                    }

                    if (requestBody == null)
                    {
                        throw new InvalidOperationException($"Invalid custom request. Body for request is null for request {index}.");
                    }

                    var outputVariables = outputVariablesNode?.Deserialize<List<RequestOutputVariable>>() ?? new List<RequestOutputVariable>();
                    return new CustomRequest(name, requestBody, outputVariables);
                })
                .ToList() ?? new List<CustomRequest>();
            if (customMapping != null)
            {
                var deserialized = customMapping.Deserialize<CustomMappingOptions>(serializeOptions);
                if (deserialized != null)
                {
                    return (deserialized, json);
                }
                else
                {
                    throw new InvalidOperationException("Failed to deserialize custom mapping options.");
                }
            }
        }

        return (new CustomMappingOptions(), string.Empty);
    }


    protected async Task AddMappingOperationsAsync(List<SetupOperation> operations, FileSource fileSource, CancellationToken cancellationToken)
    {
        using var scope = CreateLoggingScope(fileSource);
        var (customMapping, customizationFileBody) = await GetTestResultCustomizationsAsync(fileSource).ConfigureAwait(false);
        if (customMapping.EntityType != null)
        {
            var mappedType = SanitizeForEntityType(customMapping.EntityType);
            Logger.LogInformation("Using custom EntityType {EntityType}, mapped to {MappedEntityType}.", customMapping.EntityType, mappedType);
            fileSource.EntityType = mappedType;
        }
        if (customMapping.VocabularyName != null)
        {
            var mappedType = SanitizeForVocabularyName(customMapping.VocabularyName);
            Logger.LogInformation("Using custom VocabularyName {VocabularyName}, mapped to {MappedVocabularyName}.", customMapping.VocabularyName, mappedType);
            fileSource.VocabularyName = mappedType;
        }

        AddMappingCreationOperation(operations, fileSource, customMapping);

        operations.Add(CreateSetupOperation(fileSource, GetAnnotationIdAsync));
        operations.Add(CreateSetupOperation(fileSource, customMapping.OriginEntityCodeKey, SetOriginEntityCodeKeyAsync));

        AddCustomEntityTypeOperations(operations, fileSource, customizationFileBody);
        AddCustomVocabularyAndKeyOperations(operations, fileSource, customizationFileBody);
        AddPropertyMappingOperations(operations, fileSource, customMapping, customizationFileBody);
        AddEntityCodeOperations(operations, fileSource, customMapping, customizationFileBody);
        AddEntityEdgeOperations(operations, fileSource, customMapping, customizationFileBody);

        AddCustomRequestOperations(operations, fileSource, customMapping, customizationFileBody);
    }

    private void AddEntityEdgeOperations(List<SetupOperation> operations, FileSource fileSource, CustomMappingOptions customMapping, string customizationFileBody)
    {
        foreach (var entityEdge in customMapping.EntityEdges)
        {
            operations.Add(CreateSetupOperation(fileSource, entityEdge, AddEntityEdgeAsync));
        }
    }

    private void AddEntityCodeOperations(List<SetupOperation> operations, FileSource fileSource, CustomMappingOptions customMapping, string customizationFileBody)
    {
        foreach (var entityCode in customMapping.EntityCodes)
        {
            operations.Add(CreateSetupOperation(fileSource, entityCode, AddEntityCodeAsync));
        }
    }

    private void AddPropertyMappingOperations(List<SetupOperation> operations, FileSource fileSource, CustomMappingOptions customMapping, string customizationFileBody)
    {
        foreach (var keyMapping in customMapping.KeyMappings)
        {
            operations.Add(CreateSetupOperation(fileSource, keyMapping, AddPropertyMappingAsync));
        }
    }

    private void AddCustomRequestOperations(List<SetupOperation> operations, FileSource fileSource, CustomMappingOptions customMapping, string customizationFileBody)
    {
        var runtimeEnvironmentVariables = EnvironmentVariableRegex.Matches(customizationFileBody)
            .Select(match => match.Groups[1].Value)
            .Distinct()
            .ToList();
        var runtimeOutputVariables = RuntimeVariableRegex.Matches(customizationFileBody)
            .Select(match => match.Groups[1].Value)
            .Distinct()
            .ToDictionary(variable => variable, variable => string.Empty);
        var runtimeSettings = new RuntimeSettings(runtimeEnvironmentVariables, runtimeOutputVariables);
        Logger.LogInformation("Using custom mapping {CustomMapping}.", customMapping.CustomRequests.Select(x => x.Name));
        foreach (var current in customMapping.CustomRequests)
        {
            var loggingScopeState = CreateLoggingScopeState(fileSource);
            loggingScopeState.Add("MappingRequestName", current.Name);
            operations.Add(CreateSetupOperation(fileSource, current, runtimeSettings, SendCustomRequestAsync, loggingScopeState));
        }
    }

    private void AddCustomVocabularyAndKeyOperations(List<SetupOperation> operations, FileSource fileSource, string customizationFileBody)
    {
        var foundVocabularies = VocabularyRegex.Matches(customizationFileBody)
                    .Select(match => match.Groups[1].Value)
                    .Distinct()
                    .ToList();
        var foundVocabularyKeys = VocabularyKeyRegex.Matches(customizationFileBody)
            .Select(match => match.Groups[1].Value)
            .Distinct()
            .ToList();


        // Should probably be a dictionary
        var vocabulariesToCreate = foundVocabularies.Select(vocabulary => new CustomVocabulary(vocabulary)).ToList();

        if (foundVocabularies.Any())
        {
            Logger.LogInformation("Found additional Vocabulary {Vocabularies}.", string.Join(",", foundVocabularies));
        }

        if (foundVocabularyKeys.Any())
        {
            Logger.LogInformation("Found additional VocabularyKey {VocabularyKeys}.", string.Join(",", foundVocabularyKeys));
            foreach (var currentKey in foundVocabularyKeys)
            {
                var currentKeyParts = currentKey.Split('.');
                var vocabularyName = string.Join(".", currentKeyParts.SkipLast(1));
                if (!vocabulariesToCreate.Any(x => x.Name == vocabularyName))
                {
                    vocabulariesToCreate.Add(new CustomVocabulary(vocabularyName));

                }

                var vocab = vocabulariesToCreate.Single(x => x.Name == vocabularyName);
                if (!vocab.Keys.Any(key => key.Name == currentKey))
                {
                    vocab.Keys.Add(new CustomVocabularyKey(currentKeyParts.Last()));
                }
            }
        }

        Logger.LogInformation("Using custom vocabularies {CustomVocabularies} and its keys.", vocabulariesToCreate.Select(x => x.Name));
        foreach (var current in vocabulariesToCreate)
        {
            var loggingScopeState = CreateLoggingScopeState(fileSource);
            loggingScopeState.Add("CustomVocabularyName", current.Name);
            operations.Add(CreateSetupOperation(fileSource, current, CreateCustomVocabularyAsync, loggingScopeState));
        }
    }

    private void AddCustomEntityTypeOperations(List<SetupOperation> operations, FileSource fileSource, string customizationFileBody)
    {
        var foundEntityTypes = EntityTypeRegex.Matches(customizationFileBody)
            .Select(match => match.Groups[1].Value)
            .Distinct()
            .ToList();

        if (foundEntityTypes.Any())
        {
            Logger.LogInformation("Found additional EntityType(s) {EntityTypes}.", string.Join(",", foundEntityTypes));
            foreach (var currentEntityType in foundEntityTypes)
            {
                var mappedType = SanitizeForEntityType(currentEntityType);
                Logger.LogInformation("Using additional entityType {CustomEntityType}, mapped to {MappedCustomEntityType}.", currentEntityType, mappedType);
                operations.Add(CreateSetupOperation(mappedType, CreateEntityTypeIfNotExistsAsync, CreateLoggingScopeState(fileSource)));
                fileSource.CustomEntityTypesMapping.Add(currentEntityType, mappedType);
            }
        }
    }

    private void AddMappingCreationOperation(List<SetupOperation> operations, FileSource fileSource, FileSourceOperation<TOptions>.CustomMappingOptions customMapping)
    {
        operations.Add(CreateSetupOperation(fileSource, CreateEntityTypeIfNotExistsAsync));
        operations.Add(CreateSetupOperation(fileSource, CreateVocabularyIfNotExistsAsync));
        Logger.LogInformation("Using AutoMapping {ShouldAutoMap}.", customMapping.ShouldAutoMap);
        if (customMapping.ShouldAutoMap)
        {
            operations.Add(CreateSetupOperation(fileSource, CreateAutoAnnotationAsync));
        }
        else
        {
            operations.Add(CreateSetupOperation(fileSource, CreateManualAnnotationAsync));
        }
    }

    private IDisposable? CreateLoggingScope(FileSource fileSource)
    {
        return Logger.BeginScope(CreateLoggingScopeState(fileSource));
    }

    protected SetupOperation CreateSetupOperation(FileSource fileSource, Func<FileSource, CancellationToken, Task> func)
    {
        return CreateSetupOperation(fileSource, func, CreateLoggingScopeState(fileSource));
    }

    private static Dictionary<string, object> CreateLoggingScopeState(FileSource fileSource)
    {
        return new Dictionary<string, object>
        {
            ["File"] = Path.GetFileName(fileSource.UploadFilePath),
        };
    }

    protected override Task CustomizeResultAsync(SingleIterationOperationResult result, CancellationToken cancellationToken)
    {
        result.Output["FileSources"] = FileSources;
        return Task.CompletedTask;
    }

    private async Task SendCustomRequestAsync(
        FileSource fileSource,
        CustomRequest mappingRequest,
        RuntimeSettings runtimeSettings,
        CancellationToken cancellationToken)
    {
        Logger.LogDebug("Begin sending custom mapping request '{CustomMappingRequestName}'", mappingRequest.Name);
        var serverUris = await GetServerUris(cancellationToken).ConfigureAwait(false);
        var requestUri = serverUris.UiGraphqlUri;

        var body = mappingRequest.Request;
        var replacedBody = ReplaceParameters(fileSource, runtimeSettings, body);

        var requestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri)
        {
            Content = new StringContent(replacedBody, Encoding.UTF8, ApplicationJsonContentType),
        };
        var response = await SendRequestAsync(requestMessage, cancellationToken, true).ConfigureAwait(false);
        var json = await CheckResponse(response).ConfigureAwait(false);

        if (mappingRequest.OutputVariables.Any())
        {
            using var doc = JsonDocument.Parse(json);
            foreach (var outputVariable in mappingRequest.OutputVariables)
            {
                var path = outputVariable.Path;
                var results = JsonSelector.Select(doc.RootElement, path);
                if (outputVariable.IsArray)
                {
                    throw new NotSupportedException("Output Variable as an array is not supported.");
                }
                else
                {
                    if (results.Count != 1)
                    {
                        throw new InvalidOperationException($"Output variable {outputVariable.Name} count is not expected. Count is {results.Count}.");
                    }
                    var value = results.Select(elem => elem.GetString()).Single();

                    if (string.IsNullOrWhiteSpace(value))
                    {
                        throw new InvalidOperationException($"Output variable {outputVariable.Name} value '{value}' is null or whitespace.");
                    }
                    if (runtimeSettings.OutputVariables.TryGetValue(outputVariable.Name, out var retrievedValue))
                    {
                        Logger.LogDebug("Overriding runtime output variable '{VariableName}' with original value {OriginalValue} with value '{NewValue}'.",
                            outputVariable.Name,
                            retrievedValue,
                            value);
                        runtimeSettings.OutputVariables[outputVariable.Name] = value;
                    }
                    else
                    {
                        Logger.LogDebug("Adding runtime output variable '{VariableName}' with value '{VariableValue}'.", outputVariable.Name, value);
                        runtimeSettings.OutputVariables.Add(outputVariable.Name, value);
                    }
                }
            }

        }

        Logger.LogDebug("End sending custom mapping request '{CustomMappingRequestName}'", mappingRequest.Name);
    }

    private string ReplaceParameters(FileSource fileSource, RuntimeSettings runtimeSettings, string body)
    {
        var replacedBody = ReplaceFileSourceParameters(fileSource, body);
        replacedBody = ReplaceOrganizationParameters(replacedBody);
        replacedBody = ReplaceCustomEntityTypeParameters(fileSource, replacedBody);
        replacedBody = ReplaceCustomVocabularyParameters(fileSource, replacedBody);
        replacedBody = ReplaceEnvironmentVariableParameters(runtimeSettings, replacedBody);
        replacedBody = ReplaceOutputVariableParameters(runtimeSettings, replacedBody);

        return replacedBody;
    }

    private string ReplaceEnvironmentVariableParameters(RuntimeSettings runtimeSettings, string replacedBody)
    {
        Logger.LogDebug("Replacing environment variables.");
        var result = replacedBody;
        foreach (var variableName in runtimeSettings.EnvironmentVariables)
        {
            var value = SystemEnvironment.GetEnvironmentVariable(variableName);
            result = result.Replace($"{{{{Env[{variableName}]}}}}", value);
        }
        return result;
    }

    private string ReplaceOutputVariableParameters(RuntimeSettings runtimeSettings, string replacedBody)
    {
        Logger.LogDebug("Replacing environment variables.");
        var result = replacedBody;
        foreach (var variable in runtimeSettings.OutputVariables)
        {
            result = result.Replace($"{{{{Env[{variable.Key}]}}}}", variable.Value);
        }
        return result;
    }

    private static string ReplaceFileSourceParameters(FileSource fileSource, string body)
    {
        return body
            .Replace("{{AnnotationId}}", fileSource.AnnotationId.ToString())
            .Replace("{{VocabularyName}}", fileSource.VocabularyName.ToString())
            .Replace("{{VocabularyId}}", fileSource.VocabularyId.ToString())
            .Replace("{{EntityType}}", fileSource.EntityType.ToString())
            .Replace("{{DataSetId}}", fileSource.DataSetId.ToString())
            .Replace("{{DataSourceId}}", fileSource.DataSourceId.ToString());
    }

    private string ReplaceOrganizationParameters(string replacedBody)
    {
        replacedBody = replacedBody
            .Replace("{{OrganizationId}}", Organization.OrganizationId.ToString())
            .Replace("{{UserId}}", Organization.UserId.ToString());
        return replacedBody;
    }

    private static string ReplaceCustomEntityTypeParameters(FileSource fileSource, string text)
    {
        foreach (var currentMapping in fileSource.CustomEntityTypesMapping)
        {
            text = text.Replace($"{{{{EntityType[{currentMapping.Key}]}}}}", currentMapping.Value);
        }

        return text;
    }

    private static string ReplaceCustomVocabularyParameters(FileSource fileSource, string text)
    {
        foreach (var currentMapping in fileSource.CustomVocabulariesMapping)
        {
            text = text.Replace($"{{{{Vocabulary[{currentMapping.Key}].Id}}}}", currentMapping.Value.Id.ToString());
            text = text.Replace($"{{{{Vocabulary[{currentMapping.Key}].Name}}}}", currentMapping.Value.Name);
            foreach (var currentKeyMapping in currentMapping.Value.KeysMapping)
            {
                text = text.Replace($"{{{{VocabularyKey[{currentMapping.Key}.{currentKeyMapping.Key}].Id}}}}", currentKeyMapping.Value.Id.ToString());
                text = text.Replace($"{{{{VocabularyKey[{currentMapping.Key}.{currentKeyMapping.Key}].Name}}}}", currentKeyMapping.Value.Name);
            }
        }

        return text;
    }

    protected async Task CreateEntityTypeIfNotExistsAsync(string entityType, CancellationToken cancellationToken)
    {
        var entityId = await GetEntityTypeInfoAsync(entityType, cancellationToken).ConfigureAwait(false);

        if (entityId != null)
        {
            Logger.LogInformation("Skipping creation of Entity Type {EntityType} because it exists.", entityType);
            return;
        }

        Logger.LogInformation("Creating Entity Type {EntityType} because it does not exist.", entityType);
        await CreateEntityTypeAsync(entityType, cancellationToken).ConfigureAwait(false);
    }


    protected async Task<Guid?> GetEntityTypeInfoAsync(string entityType, CancellationToken cancellationToken)
    {
        var serverUris = await GetServerUris(cancellationToken).ConfigureAwait(false);
        var requestUri = serverUris.UiGraphqlUri;

        var body = await GetRequestTemplateAsync(nameof(GetEntityTypeInfoAsync)).ConfigureAwait(false);
        var replacedBody = body
            .Replace("{{EntityType}}", entityType);

        var requestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri)
        {
            Content = new StringContent(replacedBody, Encoding.UTF8, ApplicationJsonContentType),
        };
        var response = await SendRequestAsync(requestMessage, cancellationToken, true).ConfigureAwait(false);

        var result = await response.Content
            .DeserializeToAnonymousTypeAsync(new
            {
                data = new
                {
                    management = new
                    {
                        getEntityTypeInfo = new
                        {
                            id = (Guid?)null,
                            type = (string?)null,
                            route = (string?)null,
                            icon = (string?)null,
                        }
                    },
                },
            })
            .ConfigureAwait(false) ?? throw new InvalidOperationException("Invalid result because it is empty.");

        return result.data?.management?.getEntityTypeInfo?.id;
    }

    protected Task CreateEntityTypeIfNotExistsAsync(FileSource fileSource, CancellationToken cancellationToken)
    {
        return CreateEntityTypeIfNotExistsAsync(fileSource.EntityType, cancellationToken);
    }

    protected async Task CreateEntityTypeAsync(string entityType, CancellationToken cancellationToken)
    {
        var serverUris = await GetServerUris(cancellationToken).ConfigureAwait(false);
        var requestUri = serverUris.UiGraphqlUri;

        var body = await GetRequestTemplateAsync(nameof(CreateEntityTypeAsync)).ConfigureAwait(false);
        var replacedBody = body
            .Replace("{{EntityType}}", entityType)
            .Replace("{{EntityTypeRoute}}", entityType.ToLower());

        var requestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri)
        {
            Content = new StringContent(replacedBody, Encoding.UTF8, ApplicationJsonContentType),
        };
        var response = await SendRequestAsync(requestMessage, cancellationToken, true).ConfigureAwait(false);

        var result = await response.Content
            .DeserializeToAnonymousTypeAsync(new
            {
                data = new
                {
                    management = new
                    {
                        createEntityTypeConfigurationV2 = new
                        {
                            type = (string?)null,
                            route = (string?)null,
                            icon = (string?)null,
                        }
                    },
                },
            })
            .ConfigureAwait(false) ?? throw new InvalidOperationException("Invalid result because it is empty.");

        var type = result.data?.management?.createEntityTypeConfigurationV2?.type ?? throw new InvalidOperationException("Entity type not found in result.");
    }

    protected async Task CreateVocabularyIfNotExistsAsync(FileSource fileSource, CancellationToken cancellationToken)
    {
        var vocabularyId = await CreateVocabularyIfNotExistsAsync(fileSource.EntityType, fileSource.VocabularyName, cancellationToken);
        fileSource.VocabularyId = vocabularyId;
    }

    protected async Task CreateCustomVocabularyAsync(FileSource fileSource, CustomVocabulary vocabulary, CancellationToken cancellationToken)
    {
        var mappedName = SanitizeForVocabularyName(vocabulary.Name);
        Logger.LogInformation("Mapping CustomVocabularyName {CustomVocabularyName} to {MappedCustomVocabularyName}.", vocabulary.Name, mappedName);
        using var vocabularyScope = Logger.BeginScope(new Dictionary<string, object>
        {
            ["MappedCustomVocabularyName"] = mappedName,
        });

        // TODO: allow setting of custom entity type instead of just fileSource.EntityType
        var vocabularyId = await CreateVocabularyIfNotExistsAsync(mappedName, fileSource.EntityType, cancellationToken);

        var mapping = new CustomVocabularyMappingEntry
        (
            Name: mappedName,
            Id: vocabularyId
        );

        var keys = await GetVocabularyKeysFromVocabularyIdAsync(vocabularyId, cancellationToken).ConfigureAwait(false);

        await BatchCreateVocabularyKeys(vocabulary, vocabularyId, mapping, keys, cancellationToken).ConfigureAwait(false);
        fileSource.CustomVocabulariesMapping.Add(vocabulary.Name, mapping);
    }

    private async Task BatchCreateVocabularyKeys(CustomVocabulary vocabulary, Guid vocabularyId, CustomVocabularyMappingEntry mapping, List<(Guid KeyId, string Name)> existingKeys, CancellationToken cancellationToken)
    {
        var serverUris = await GetServerUris(cancellationToken).ConfigureAwait(false);
        var requestUri = serverUris.UiGraphqlUri;

        var keys = new List<CreateVocabularyKeyModel>();
        foreach (var vocabularyKey in vocabulary.Keys)
        {
            if (keys.Any(key => key.Name == vocabularyKey.Name))
            {
                Logger.LogInformation("Skipping creation of VocabularyKeyName {VocabularyKeyName} because it exists.", vocabularyKey.Name);
                continue;
            }

            Logger.LogInformation("Creating VocabularyKeyName {VocabularyKeyName} because it does not exist.", vocabularyKey.Name);
            keys.Add(new CreateVocabularyKeyModel
            (
                VocabularyId: vocabularyId,
                DisplayName: vocabularyKey.Name,
                Name: vocabularyKey.Name,
                DataType: "Text",
                Storage: vocabularyKey.Storage,
                IsVisible: true,
                GroupName: vocabularyKey.GroupName
            ));
        }

        var requestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri)
        {
            Content = new StringContent(JsonSerializer.Serialize(keys), Encoding.UTF8, ApplicationJsonContentType),
        };

        var response = await SendRequestAsync(requestMessage, cancellationToken, true).ConfigureAwait(false);
        var result = await response.Content
            .DeserializeToAnonymousTypeAsync(new[]
            {
                new
                {
                    vocabularyKey = string.Empty,
                    status = string.Empty,
                    id = (Guid?)null,
                    error = (string?)null,
                }
            })
            .ConfigureAwait(false) ?? throw new InvalidOperationException("Invalid result because it is empty.");

        foreach (var keyResult in result)
        {
            var keyId = Guid.Empty;
            if (keyResult.status != "Success")
            {
                Logger.LogWarning("An error occurred while trying to create vocabulary key. However, it might be already created. Polling to check.");
                var (vocabularyKeyId, _) = await PollForVocabularyKeyCreationCompletionAsync(vocabularyId, keyResult.vocabularyKey, cancellationToken).ConfigureAwait(false);
                keyId = vocabularyKeyId;
            }
            keyId = keyResult.id.GetValueOrDefault();
            if (keyId == Guid.Empty)
            {
                throw new InvalidOperationException("Invalid key id. It is empty.");
            }
            mapping.KeysMapping.Add(keyResult.vocabularyKey, new CustomVocabularyKeyMappingEntry
            (
                Name: keyResult.vocabularyKey,
                Id: keyId
            ));
        }
        await Task.Delay(TimeSpan.FromMilliseconds(Options.DelayAfterVocabularyKeyCreationInMilliseconds), cancellationToken);
    }

    private async Task CreateVocabularyKeys(CustomVocabulary vocabulary, Guid vocabularyId, CustomVocabularyMappingEntry mapping, List<(Guid KeyId, string Name)> keys, CancellationToken cancellationToken)
    {
        foreach (var vocabularyKey in vocabulary.Keys)
        {
            using var vocabularyKeyScope = Logger.BeginScope(new Dictionary<string, object>
            {
                ["CustomVocabularyKeyName"] = vocabularyKey.Name,
            });
            if (keys.Any(key => key.Name == vocabularyKey.Name))
            {
                Logger.LogInformation("Skipping creation of VocabularyKeyName {VocabularyKeyName} because it exists.", vocabularyKey.Name);
                continue;
            }

            Logger.LogInformation("Creating VocabularyKeyName {VocabularyKeyName} because it does not exist.", vocabularyKey.Name);
            await Task.Delay(TimeSpan.FromMilliseconds(Options.DelayAfterVocabularyKeyCreationInMilliseconds), cancellationToken);

            var keyId = Guid.Empty;
            try
            {
                keyId = await CreateVocabularyKeyAsync(vocabularyId, vocabularyKey, cancellationToken).ConfigureAwait(false);
            }
            catch (InvalidOperationException ex)
            {
                Logger.LogWarning(ex, "An error occurred while trying to create vocabulary key. However, it might be already created. Polling to check.");
                var (vocabularyKeyId, _) = await PollForVocabularyKeyCreationCompletionAsync(vocabularyId, vocabularyKey.Name, cancellationToken).ConfigureAwait(false);
                keyId = vocabularyKeyId;
            }
            mapping.KeysMapping.Add(vocabularyKey.Name, new CustomVocabularyKeyMappingEntry
            (
                Name: vocabularyKey.Name,
                Id: keyId
            ));
        }
    }

    protected async Task<(Guid VocabularyKeyId, List<(Guid KeyId, string Name)> AllKeys)> PollForVocabularyKeyCreationCompletionAsync(Guid vocabularyId, string keyName, CancellationToken cancellationToken)
    {
        // Server has issues if we create multiple vocabularies in quick succession,
        // Sometimes it says vocabulary does not exist, when it does,
        // We need to ensure that it exists first before processing

        for (var i = 0; i < MaximumVocabularyCreationPoll; ++i)
        {
            Logger.LogInformation("Waiting for {DelayAfterVocabularyCreation} before checking whether vocabulary key {VocabularyKeyName} exists.",
                DelayAfterVocabularyCreationPoll,
                keyName);
            await Task.Delay(DelayAfterVocabularyCreationPoll, cancellationToken).ConfigureAwait(false);
            try
            {
                var keys = await GetVocabularyKeysFromVocabularyIdAsync(vocabularyId, cancellationToken).ConfigureAwait(false);

                var foundKey = keys.SingleOrDefault(key => key.Name == keyName);
                if (foundKey != default)
                {
                    Logger.LogInformation("Finish polling for {VocabularyKeyName}.", keyName);
                    return (foundKey.KeyId, keys);
                }
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Failed to poll for {VocabularyKeyName}.", keyName);
            }
        }

        throw new InvalidOperationException($"Failed to ensure that vocabulary key {keyName} exists.");
    }

    protected async Task<Guid> PollForVocabularyCreationCompletionAsync(string vocabularyName, CancellationToken cancellationToken)
    {
        // Server has issues if we create multiple vocabularies in quick succession,
        // Sometimes it says vocabulary does not exist, when it does,
        // We need to ensure that it exists first before processing

        for (var i = 0; i < MaximumVocabularyCreationPoll; ++i)
        {
            Logger.LogInformation("Waiting for {DelayAfterVocabularyCreation} before checking whether vocabulary {VocabularyName} exists.",
                DelayAfterVocabularyCreationPoll,
                vocabularyName);
            await Task.Delay(DelayAfterVocabularyCreationPoll, cancellationToken).ConfigureAwait(false);
            try
            {
                var vocabularyId = await GetVocabularyIdFromName(vocabularyName, cancellationToken).ConfigureAwait(false);

                if (vocabularyId != null)
                {
                    Logger.LogInformation("Finish polling for {VocabularyName}.", vocabularyName);
                    return vocabularyId.Value;
                }
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Failed to poll for {VocabularyName}.", vocabularyName);
            }
        }

        throw new InvalidOperationException($"Failed to ensure that vocabulary {vocabularyName} exists.");
    }

    protected async Task<Guid> CreateVocabularyIfNotExistsAsync(string vocabularyName, string entityType, CancellationToken cancellationToken)
    {
        var vocabularyId = await GetVocabularyIdFromName(vocabularyName, cancellationToken).ConfigureAwait(false);

        if (vocabularyId != null)
        {
            Logger.LogInformation("Skipping creation of VocabularyName {VocabularyName} because it exists.", vocabularyName);
            return vocabularyId.Value;
        }

        Logger.LogInformation("Creating VocabularyName {VocabularyName} because it does not exist.", vocabularyName);
        return await CreateVocabularyAsync(vocabularyName, entityType, cancellationToken).ConfigureAwait(false);
    }

    protected async Task<Guid?> GetVocabularyIdFromName(string vocabularyName, CancellationToken cancellationToken)
    {
        var serverUris = await GetServerUris(cancellationToken).ConfigureAwait(false);
        var requestUri = serverUris.UiGraphqlUri;

        var body = await GetRequestTemplateAsync("GetAllVocabulariesAsync").ConfigureAwait(false);
        var replacedBody = body
            .Replace("{{VocabularyName}}", vocabularyName);

        var requestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri)
        {
            Content = new StringContent(replacedBody, Encoding.UTF8, ApplicationJsonContentType),
        };
        var response = await SendRequestAsync(requestMessage, cancellationToken, true).ConfigureAwait(false);

        var result = await response.Content
            .DeserializeToAnonymousTypeAsync(new
            {
                data = new
                {
                    management = new
                    {
                        vocabularies = new
                        {
                            data = new[]
                            {
                                new
                                {
                                    vocabularyId = (Guid?)null,
                                    vocabularyName = (string?)null,
                                    keyPrefix = (string?)null,
                                }
                            }
                        }
                    },
                },
            })
            .ConfigureAwait(false) ?? throw new InvalidOperationException("Invalid result because it is empty.");

        return result.data?.management?.vocabularies?.data?.SingleOrDefault(vocabulary => vocabulary.vocabularyName == vocabularyName)?.vocabularyId;
    }

    protected async Task<Guid> CreateVocabularyAsync(string vocabularyName, string entityType, CancellationToken cancellationToken)
    {
        var serverUris = await GetServerUris(cancellationToken).ConfigureAwait(false);
        var requestUri = serverUris.UiGraphqlUri;

        var body = await GetRequestTemplateAsync(nameof(CreateVocabularyAsync)).ConfigureAwait(false);
        var replacedBody = body
            .Replace("{{VocabularyName}}", vocabularyName)
            .Replace("{{EntityType}}", entityType);

        var requestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri)
        {
            Content = new StringContent(replacedBody, Encoding.UTF8, ApplicationJsonContentType),
        };
        var response = await SendRequestAsync(requestMessage, cancellationToken, true).ConfigureAwait(false);

        var result = await response.Content
            .DeserializeToAnonymousTypeAsync(new
            {
                data = new
                {
                    management = new
                    {
                        createVocabulary = new 
                        {
                            vocabularyId = (Guid?)null,
                        }
                    },
                },
            })
            .ConfigureAwait(false) ?? throw new InvalidOperationException("Invalid result because it is empty.");

        return await PollForVocabularyCreationCompletionAsync(vocabularyName, cancellationToken).ConfigureAwait(false);
    }

    protected async Task<List<(Guid KeyId, string Name)>> GetVocabularyKeysFromVocabularyIdAsync(Guid vocabularyId, CancellationToken cancellationToken)
    {
        var serverUris = await GetServerUris(cancellationToken).ConfigureAwait(false);
        var requestUri = serverUris.UiGraphqlUri;

        var body = await GetRequestTemplateAsync("GetVocabularyKeysFromVocabularyIdAsync").ConfigureAwait(false);
        var replacedBody = body
            .Replace("{{VocabularyId}}", vocabularyId.ToString());

        var requestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri)
        {
            Content = new StringContent(replacedBody, Encoding.UTF8, ApplicationJsonContentType),
        };
        var response = await SendRequestAsync(requestMessage, cancellationToken, true).ConfigureAwait(false);

        var result = await response.Content
            .DeserializeToAnonymousTypeAsync(new
            {
                data = new
                {
                    management = new
                    {
                        vocabularyKeysFromVocabularyId = new
                        {
                            data = new[]
                            {
                                new
                                {
                                    vocabularyKeyId = (Guid?)null,
                                    name = (string?)null,
                                    key = (string?)null,
                                    dataType = (string?)null,
                                    groupName = (string?)null,
                                }
                            }
                        }
                    },
                },
            })
            .ConfigureAwait(false) ?? throw new InvalidOperationException("Invalid result because it is empty.");

        return result.data?.management?.vocabularyKeysFromVocabularyId?.data?.Select(key => (key.vocabularyKeyId.Value, key.name!))?.ToList() ?? new ();
    }

    protected async Task<Guid> CreateVocabularyKeyAsync(Guid vocabularyId, CustomVocabularyKey vocabularyKey, CancellationToken cancellationToken)
    {
        var serverUris = await GetServerUris(cancellationToken).ConfigureAwait(false);
        var requestUri = serverUris.UiGraphqlUri;

        var body = await GetRequestTemplateAsync(nameof(CreateVocabularyKeyAsync)).ConfigureAwait(false);
        var replacedBody = body
            .Replace("{{VocabularyId}}", vocabularyId.ToString())
            .Replace("{{VocabularyKeyName}}", vocabularyKey.Name)
            .Replace("{{VocabularyKeyType}}", "Text") // TODO: allow setting of type
            .Replace("{{VocabularyKeyGroup}}", "Metadata");

        var requestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri)
        {
            Content = new StringContent(replacedBody, Encoding.UTF8, ApplicationJsonContentType),
        };
        var response = await SendRequestAsync(requestMessage, cancellationToken, true).ConfigureAwait(false);

        var result = await response.Content
            .DeserializeToAnonymousTypeAsync(new
            {
                data = new
                {
                    management = new
                    {
                        createVocabularyKey = new
                        {
                            vocabularyKeyId = (Guid?)null,
                        }
                    },
                },
            })
            .ConfigureAwait(false) ?? throw new InvalidOperationException("Invalid result because it is empty.");

        var keyId = result.data?.management?.createVocabularyKey?.vocabularyKeyId ?? throw new InvalidOperationException("VocabularyKeyId is not found in result.");
        return keyId;
    }

    protected async Task CreateDataSourceSetAsync(FileSource fileSource, CancellationToken cancellationToken)
    {
        var serverUris = await GetServerUris(cancellationToken).ConfigureAwait(false);
        var requestUri = serverUris.UiGraphqlUri;

        var body = await GetRequestTemplateAsync(nameof(CreateDataSourceSetAsync)).ConfigureAwait(false);
        var replacedBody = body.Replace("{{UserId}}", Organization.UserId.ToString())
            .Replace("{{DataSourceSetName}}", Path.GetFileNameWithoutExtension(fileSource.UploadFilePath));

        var requestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri)
        {
            Content = new StringContent(replacedBody, Encoding.UTF8, ApplicationJsonContentType),
        };
        var response = await SendRequestAsync(requestMessage, cancellationToken, true).ConfigureAwait(false);

        var result = await response.Content
            .DeserializeToAnonymousTypeAsync(new
            {
                data = new
                {
                    inbound = new
                    {
                        createDataSourceSet = (int?)null,
                    },
                },
            })
            .ConfigureAwait(false) ?? throw new InvalidOperationException("Invalid result because it is empty.");

        int? resultDataSourceSetId = result.data?.inbound?.createDataSourceSet ?? throw new InvalidOperationException("DataSourceSetId is not found in result.");

        fileSource.DataSourceSetId = resultDataSourceSetId.Value;
    }

    protected async Task AddPropertyMappingAsync(FileSource fileSource, KeyMapping keyMapping, CancellationToken cancellationToken)
    {
        var serverUris = await GetServerUris(cancellationToken).ConfigureAwait(false);
        var requestUri = serverUris.UiGraphqlUri;

        var body = await GetRequestTemplateAsync(nameof(AddPropertyMappingAsync)).ConfigureAwait(false);
        var (vocabularyId, vocabularyKeyId) = GetVocabularyKeyDetails(fileSource, keyMapping.Key);
        var replacedBody = body
            .Replace("{{DataSetId}}", fileSource.DataSetId.ToString())
            .Replace("{{OriginalField}}", keyMapping.Field)
            .Replace("{{UseAsAlias}}", keyMapping.UseAsAlias.ToString().ToLowerInvariant())
            .Replace("{{UseAsEntityCode}}", keyMapping.UseAsEntityCode.ToString().ToLowerInvariant())
            .Replace("{{VocabularyId}}", vocabularyId.ToString())
            .Replace("{{VocabularyKeyId}}", vocabularyKeyId.ToString());

        replacedBody = ReplaceCustomVocabularyParameters(fileSource, keyMapping.Key);

        var requestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri)
        {
            Content = new StringContent(replacedBody, Encoding.UTF8, ApplicationJsonContentType),
        };
        var response = await SendRequestAsync(requestMessage, cancellationToken, true).ConfigureAwait(false);

        _ = await CheckResponse(response);
    }

    protected async Task<HttpResponseMessage> GetDataSourceByIdAsync(FileSource fileSource, CancellationToken cancellationToken)
    {
        var serverUris = await GetServerUris(cancellationToken).ConfigureAwait(false);
        var requestUri = serverUris.UiGraphqlUri;

        var body = await GetRequestTemplateAsync(nameof(GetDataSourceByIdAsync)).ConfigureAwait(false);
        var replacedBody = body.Replace("{{DataSourceId}}", fileSource.DataSourceId.ToString());

        var requestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri)
        {
            Content = new StringContent(replacedBody, Encoding.UTF8, ApplicationJsonContentType),
        };

        var response = await SendRequestAsync(requestMessage, cancellationToken, true).ConfigureAwait(false);
        return response;
    }

    protected async Task CreateAutoAnnotationAsync(FileSource fileSource, CancellationToken cancellationToken)
    {
        var serverUris = await GetServerUris(cancellationToken).ConfigureAwait(false);
        var requestUri = serverUris.UiGraphqlUri;

        var body = await GetRequestTemplateAsync(nameof(CreateAutoAnnotationAsync)).ConfigureAwait(false);
        var replacedBody = body.Replace("{{DataSetId}}", fileSource.DataSetId.ToString())
            .Replace("{{VocabularyName}}", fileSource.VocabularyName)
            .Replace("{{VocabularyId}}", fileSource.VocabularyId.ToString())
            .Replace("{{EntityType}}", fileSource.EntityType);

        var requestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri)
        {
            Content = new StringContent(replacedBody, Encoding.UTF8, ApplicationJsonContentType),
        };

        var response = await SendRequestAsync(requestMessage, cancellationToken, true).ConfigureAwait(false);
        _ = await CheckResponse(response).ConfigureAwait(false);
        _ = await PollForVocabularyCreationCompletionAsync(fileSource.VocabularyName, cancellationToken).ConfigureAwait(false);
    }

    protected async Task CreateManualAnnotationAsync(FileSource fileSource, CancellationToken cancellationToken)
    {
        var serverUris = await GetServerUris(cancellationToken).ConfigureAwait(false);
        var requestUri = serverUris.UiGraphqlUri;

        var body = await GetRequestTemplateAsync(nameof(CreateManualAnnotationAsync)).ConfigureAwait(false);
        var replacedBody = body.Replace("{{DataSetId}}", fileSource.DataSetId.ToString())
            .Replace("{{VocabularyName}}", fileSource.VocabularyName)
            .Replace("{{VocabularyId}}", fileSource.VocabularyId.ToString())
            .Replace("{{EntityType}}", fileSource.EntityType)
            .Replace("{{KeysConfig}}", JsonSerializer.Serialize(new string[] { })); // TODO: Add Keysconfig

        var requestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri)
        {
            Content = new StringContent(replacedBody, Encoding.UTF8, ApplicationJsonContentType),
        };

        var response = await SendRequestAsync(requestMessage, cancellationToken, true).ConfigureAwait(false);
        _ = await CheckResponse(response).ConfigureAwait(false);
    }

    protected async Task AddEntityEdgeAsync(FileSource fileSource, EntityEdge entityEdge, CancellationToken cancellationToken)
    {
        var serverUris = await GetServerUris(cancellationToken).ConfigureAwait(false);
        var requestUri = serverUris.UiGraphqlUri;

        var vocabularyKeyFullName = ReplaceCustomVocabularyParameters(fileSource, entityEdge.Key);
        var entityType = ReplaceCustomEntityTypeParameters(fileSource, entityEdge.EntityType);
        var body = await GetRequestTemplateAsync(nameof(AddEntityCodeAsync)).ConfigureAwait(false);
        var replacedBody = body.Replace("{{AnnotationId}}", fileSource.AnnotationId.ToString())
            .Replace("{{VocabularyKeyFullName}}", vocabularyKeyFullName)
            .Replace("{{EntityType}}", entityType)
            .Replace("{{EdgeType}}", entityEdge.EdgeType)
            .Replace("{{Origin}}", entityEdge.Origin)
            .Replace("{{EdgeDirection}}", entityEdge.Direction);

        var requestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri)
        {
            Content = new StringContent(replacedBody, Encoding.UTF8, ApplicationJsonContentType),
        };

        var response = await SendRequestAsync(requestMessage, cancellationToken, true).ConfigureAwait(false);
        _ = await CheckResponse(response).ConfigureAwait(false);
    }

    protected async Task AddEntityCodeAsync(FileSource fileSource, EntityCode entityCode, CancellationToken cancellationToken)
    {
        var serverUris = await GetServerUris(cancellationToken).ConfigureAwait(false);
        var requestUri = serverUris.UiGraphqlUri;

        var vocabularyKeyFullName = ReplaceCustomVocabularyParameters(fileSource, entityCode.Key);
        var body = await GetRequestTemplateAsync(nameof(AddEntityCodeAsync)).ConfigureAwait(false);
        var replacedBody = body.Replace("{{AnnotationId}}", fileSource.AnnotationId.ToString())
            .Replace("{{VocabularyKeyFullName}}", vocabularyKeyFullName)
            .Replace("{{Origin}}", fileSource.VocabularyId.ToString());

        var requestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri)
        {
            Content = new StringContent(replacedBody, Encoding.UTF8, ApplicationJsonContentType),
        };

        var response = await SendRequestAsync(requestMessage, cancellationToken, true).ConfigureAwait(false);
        _ = await CheckResponse(response).ConfigureAwait(false);
    }

    protected async Task GetAnnotationIdAsync(FileSource fileSource, CancellationToken cancellationToken)
    {
        var response = await GetDataSourceByIdAsync(fileSource, cancellationToken).ConfigureAwait(false);
        var result = await response.Content
            .DeserializeToAnonymousTypeAsync(new
            {
                data = new
                {
                    inbound = new
                    {
                        dataSource = new
                        {
                            dataSets = new[]
                            {
                            new
                            {
                                annotationId = (int?)null
                            },
                            },
                        },
                    },
                },
            }).ConfigureAwait(false) ?? throw new InvalidOperationException("Invalid result because it is empty.");

        int? annotationId = result.data?.inbound?.dataSource?.dataSets?[0]?.annotationId ?? throw new InvalidOperationException("AnnotationId is not found in result.");

        fileSource.AnnotationId = annotationId.Value;
    }

    protected async Task SetNameKeyAsync(FileSource fileSource, string nameKey, CancellationToken cancellationToken)
    {
        var serverUris = await GetServerUris(cancellationToken).ConfigureAwait(false);
        var requestUri = serverUris.UiGraphqlUri;

        var body = await GetRequestTemplateAsync(nameof(SetNameKeyAsync)).ConfigureAwait(false);
        var replacedNameKey = ReplaceCustomVocabularyParameters(fileSource, nameKey);
        var replacedBody = body
            .Replace("{{AnnotationId}}", fileSource.AnnotationId.ToString())
            .Replace("{{VocabularyKeyFullName}}", replacedNameKey);

        var requestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri)
        {
            Content = new StringContent(replacedBody, Encoding.UTF8, ApplicationJsonContentType),
        };
        var response = await SendRequestAsync(requestMessage, cancellationToken, true).ConfigureAwait(false);
        _ = await CheckResponse(response);
    }


    protected async Task SetOriginEntityCodeKeyAsync(FileSource fileSource, string origin, CancellationToken cancellationToken)
    {
        var serverUris = await GetServerUris(cancellationToken).ConfigureAwait(false);
        var requestUri = serverUris.UiGraphqlUri;

        var body = await GetRequestTemplateAsync(nameof(SetOriginEntityCodeKeyAsync)).ConfigureAwait(false);
        var replacedOrigin = ReplaceCustomVocabularyParameters(fileSource, origin);
        var replacedBody = body
            .Replace("{{AnnotationId}}", fileSource.AnnotationId.ToString())
            .Replace("{{Origin}}", replacedOrigin);

        var requestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri)
        {
            Content = new StringContent(replacedBody, Encoding.UTF8, ApplicationJsonContentType),
        };
        var response = await SendRequestAsync(requestMessage, cancellationToken, true).ConfigureAwait(false);
        _ = await CheckResponse(response);
    }

    private static (Guid VocabularyId, Guid VocabularyKeyId) GetVocabularyKeyDetails(FileSource fileSource, string fullVocabularyKey)
    {
        var indexOfKey = fullVocabularyKey.IndexOf("}}.");
        if (indexOfKey == -1)
        {
            var vocabulary = fullVocabularyKey[..(indexOfKey + 2)];
            var vocabularyKeyName = fullVocabularyKey[(indexOfKey + 3)..];
            var vocabularyMapping = fileSource.CustomVocabulariesMapping
                .Where(currentMapping => $"{{{{Vocabulary[{currentMapping.Key}].Name}}}}" == vocabulary)
                .Select(currentMapping => currentMapping.Value)
                .SingleOrDefault();

            if (vocabularyMapping != null)
            {
                if (vocabularyMapping.KeysMapping.TryGetValue(vocabularyKeyName, out var keyMapping))
                {
                    return (vocabularyMapping.Id, keyMapping.Id);
                }
            }
        }

        throw new InvalidOperationException($"Cannot resolve vocabulary id details from key '{fullVocabularyKey}'.");
    }

    private void CreateFileSources(string testId)
    {
        IEnumerable<string> files = Array.Empty<string>();
        if (!string.IsNullOrWhiteSpace(Options.InputDirectoryPath))
        {
            if (!Directory.Exists(Options.InputDirectoryPath))
            {
                throw new InvalidOperationException($"Input directory '{Options.InputDirectoryPath}' does not exist.");
            }
            files = Directory.GetFiles(Options.InputDirectoryPath)
                .Where(file => !file.EndsWith(".customization.json"));
        }
        else
        {
            if (string.IsNullOrWhiteSpace(Options.InputFilePath))
            {
                throw new InvalidOperationException($"Input file '{Options.InputFilePath}' is invalid.");
            }
            files = new string[]
            {
                Options.InputFilePath
            };
        }

        if (!files.Any())
        {
            throw new InvalidOperationException("No input files found.");
        }

        Logger.LogInformation("There are {TotalFiles} files to be processed.", files.Count());
        EntityTypePrefix = $"testX{testId}";
        FileSources = files.Select((file, fileIndex) =>
        {
            var fileNameWithoutExtension = Path.GetFileNameWithoutExtension(file);
            var entityType = SanitizeForEntityType($"{fileIndex}x{fileNameWithoutExtension}");

            return new FileSource
            {
                UploadFilePath = file,
                IsExternalUploadFilePath = TestFileHelper.IsExternalTestFile(file),
                VocabularyName = entityType,
                EntityType = entityType,
            };
        }).ToList();
    }

    private string SanitizeForEntityType(string suffix)
    {
        var sanitizedSuffix = InvalidEntityTypeNameRegex.Replace(suffix, string.Empty);
        var entityType = $"{EntityTypePrefix}x{sanitizedSuffix}";
        if (entityType.Length > MaximumKeyPrefixLength)
        {
            entityType = entityType[..MaximumKeyPrefixLength];
        }

        return entityType;
    }

    private string SanitizeForVocabularyName(string suffix)
    {
        var sanitizedSuffix = InvalidVocabularyNameRegex.Replace(suffix, string.Empty);
        var entityType = $"{EntityTypePrefix}x{sanitizedSuffix}";
        if (entityType.Length > MaximumKeyPrefixLength)
        {
            entityType = entityType[..MaximumKeyPrefixLength];
        }

        return entityType;
    }

    private async Task<int> GetNumberOfCluesAsync(CancellationToken cancellationToken)
    {
        var counter = 0;
        string? line;

        using var streamReader = new StreamReader(TestFileHelper.GetTestFileStream(Options.InputFilePath));
        while ((line = await streamReader.ReadLineAsync().ConfigureAwait(false)) != null)
        {
            counter++;
        }

        return counter - 1; //assume header row exists
    }

    protected Stream GetUploadFileStream(FileSource fileSource)
    {
        return TestFileHelper.GetTestFileStream(fileSource.UploadFilePath);
    }

    private static async Task<string> CheckResponse(HttpResponseMessage response)
    {
        var json = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
        var result = json
                    .DeserializeToAnonymousType(new
                    {
                        errors = (GraphQLError[]?)null,
                    }) ?? throw new InvalidOperationException("Invalid result because it is empty.");

        CheckForErrors(result.errors);
        return json;
    }

    private static void CheckForErrors(GraphQLError[]? errors)
    {
        if (errors != null && errors.Any())
        {
            throw new InvalidOperationException($"Failed to perform operation because '{string.Join(',', errors.Select(error => error.Message))}'.");
        }
    }

    protected class CustomMappingOptions
    {
        public bool ShouldAutoMap { get; set; } = true;

        public string? EntityType { get; set; }

        public string? VocabularyName { get; set; }

        public string OriginEntityCodeKey { get; set; } = AutoGeneratedKey;

        public string? Origin { get; set; }

        public string? NameKey { get; set; }

        public IEnumerable<KeyMapping> KeyMappings { get; set; } = Enumerable.Empty<KeyMapping>();

        public IEnumerable<EntityCode> EntityCodes { get; set; } = Enumerable.Empty<EntityCode>();

        public IEnumerable<EntityEdge> EntityEdges { get; set; } = Enumerable.Empty<EntityEdge>();

        [JsonIgnore]
        public IEnumerable<CustomRequest> CustomRequests { get; set; } = Enumerable.Empty<CustomRequest>();
    }

    protected record EntityCode(string Key, string Origin, bool UseAsEntityCode, bool UseAsSourceCode);

    protected record EntityEdge(string Key, string EdgeType, string Origin, string EntityType, string Direction);

    protected record KeyMapping(string Field, string Key, bool UseAsEntityCode, bool UseAsAlias);

    protected record CustomRequest(string Name, string Request, List<RequestOutputVariable> OutputVariables);

    protected record RequestOutputVariable(string Name, string Path, bool IsArray = false);

    protected record RuntimeSettings(List<string> EnvironmentVariables, Dictionary<string, string> OutputVariables);

    protected record CustomVocabulary(string Name)
    {
        public List<CustomVocabularyKey> Keys { get; init; } = new List<CustomVocabularyKey>();
    }

    protected record CustomVocabularyKey(string Name, string DataType = "Text", string Storage = "Untyped", string GroupName = "Metadata");

    protected class GraphQLError
    {
        public string? Message { get; set; }
    }

    private record CreateVocabularyKeyModel(
        Guid VocabularyId,
        string DisplayName,
        string Name,
        string DataType,
        string Storage,
        bool IsVisible,
        string GroupName);
}
