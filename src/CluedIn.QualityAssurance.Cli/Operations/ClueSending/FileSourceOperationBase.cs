using System.Text;
using System.Text.Json.Nodes;
using System.Text.Json.Serialization;
using System.Text.Json;
using Microsoft.Extensions.Logging;
using CluedIn.QualityAssurance.Cli.Models.Operations;
using Spectre.Console;
using CluedIn.QualityAssurance.Cli.Environments;
using CluedIn.QualityAssurance.Cli.Services.RabbitMQ;
using CluedIn.QualityAssurance.Cli.Services.ResultWriters;
using CluedIn.QualityAssurance.Cli.Services.PostOperationActions;
using System.Text.RegularExpressions;
using System.IO;
using System.Threading;

namespace CluedIn.QualityAssurance.Cli.Operations.ClueSending;

internal abstract class FileSourceOperationBase<TOptions> : ClueSendingOperation<TOptions>
    where TOptions : IClueSendingOperationOptions, IFileSourceOperationOptions
{
    private static readonly Regex InvalidEntityTypeNameRegex = new Regex("[^a-zA-Z0-9]");
    public FileSourceOperationBase(
        ILogger<FileSourceOperationBase<TOptions>> logger,
        IEnvironment testEnvironment,
        IEnumerable<IResultWriter> resultWriters,
        IRabbitMQCompletionChecker rabbitMqCompletionChecker,
        IEnumerable<IPostOperationAction> postOperationActions,
        IHttpClientFactory httpClientFactory)
        : base(logger, testEnvironment, resultWriters, rabbitMqCompletionChecker, postOperationActions, httpClientFactory)
    {
        Logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    protected ICollection<FileSource> FileSources { get; set; }

    private ILogger<FileSourceOperationBase<TOptions>> Logger { get; }

    protected override async Task CreateOperationData(int iterationNumber)
    {
        CreateFileSources(CreateTestId(iterationNumber));
        await base.CreateOperationData(iterationNumber);
    }

    private async Task<CustomMappingOptions> GetTestResultCustomizationsAsync(FileSource fileSource)
    {
        var customizationFileStream = TestFileHelper.GetCustomizationFileStream(fileSource.UploadFilePath);
        if (customizationFileStream != null)
        {
            using var reader = new StreamReader(customizationFileStream);
            var json = await reader.ReadToEndAsync();

            var jsonObj = JsonNode.Parse(json);
            var serializeOptions = new JsonSerializerOptions
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                Converters =
                {
                    new JsonStringEnumConverter()
                }
            };

            var customMapping = jsonObj?["customMapping"];

            var requests = customMapping?["requests"]?.AsArray()?.Select(x => new CustomMappingRequest
            {
                Name = x["name"].Deserialize<string>(),
                Request = x["request"].ToString(),
            }).ToList() ?? new List<CustomMappingRequest>();

            return new CustomMappingOptions
            {
                ShouldAutoGenerateOriginEntityCodeKey = customMapping?["shouldAutoGenerateOriginEntityCodeKey"]?.AsValue().GetValue<bool?>() ?? true,
                MappingRequests = requests,
            };
        }

        return new CustomMappingOptions();
    }

    protected async Task AddMappingModificationsAsync(FileSource fileSource, List<SetupOperation> operations, CancellationToken cancellationToken)
    {
        using var scope = CreateLoggingScope(fileSource);
        var customMapping = await GetTestResultCustomizationsAsync(fileSource).ConfigureAwait(false);
        if (customMapping.ShouldAutoGenerateOriginEntityCodeKey)
        {
            operations.Add(new SetupOperation(cancellationToken => SetAutoGeneratedOriginEntityCodeKeyAsync(fileSource, cancellationToken), nameof(SetAutoGeneratedOriginEntityCodeKeyAsync)));
        }

        Logger.LogInformation("Using customization with ShouldAutoGenerateOriginEntityCodeKey {ShouldAutoGenerateOriginEntityCodeKey} and mapping {CustomMapping}.",
            customMapping.ShouldAutoGenerateOriginEntityCodeKey,
            customMapping.MappingRequests.Select(x => x.Name));
        foreach (var current in customMapping.MappingRequests)
        {
            operations.Add(new SetupOperation(cancellationToken => SendCustomMappingRequestAsync(fileSource, current, cancellationToken), nameof(SendCustomMappingRequestAsync)));
        }
    }

    private IDisposable? CreateLoggingScope(FileSource fileSource)
    {
        return this.Logger.BeginScope(CreateLoggingScopeState(fileSource));
    }

    protected SetupOperation CreateSetupOperation(FileSource fileSource, Func<FileSource, CancellationToken, Task> func)
    {
        return new SetupOperation(
            cancellationToken => func(fileSource, cancellationToken),
            func.Method.Name,
            CreateLoggingScopeState(fileSource));
    }

    private static Dictionary<string, object> CreateLoggingScopeState(FileSource fileSource)
    {
        return new Dictionary<string, object>
        {
            ["File"] = Path.GetFileName(fileSource.UploadFilePath),
        };
    }

    protected async Task SendCustomMappingRequestAsync(FileSource fileSource, CustomMappingRequest mappingRequest, CancellationToken cancellationToken)
    {
        Logger.LogDebug("Begin sending custom mapping request '{CustomMappingRequestName}'", mappingRequest.Name);
        var serverUris = await GetServerUris(cancellationToken).ConfigureAwait(false);
        var requestUri = serverUris.UiGraphqlUri;

        var body = mappingRequest.Request;
        var replacedBody = body
            .Replace("{{AnnotationId}}", fileSource.AnnotationId.ToString())
            .Replace("{{VocabularyKey}}", fileSource.VocabularyKey.ToString())
            .Replace("{{EntityType}}", fileSource.EntityType.ToString())
            .Replace("{{OrganizationId}}", Organization.OrganizationId.ToString())
            .Replace("{{UserId}}", Organization.UserId.ToString())
            .Replace("{{DataSetId}}", fileSource.DataSetId.ToString())
            .Replace("{{DataSourceId}}", fileSource.DataSourceId.ToString());

        var requestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri)
        {
            Content = new StringContent(replacedBody, Encoding.UTF8, "application/json"),
        };
        _ = await SendRequestAsync(requestMessage, cancellationToken, true).ConfigureAwait(false);
        Logger.LogDebug("End sending custom mapping request '{CustomMappingRequestName}'", mappingRequest.Name);
    }

    protected async Task CreateDataSourceSetAsync(FileSource fileSource, CancellationToken cancellationToken)
    {
        var serverUris = await GetServerUris(cancellationToken).ConfigureAwait(false);
        var requestUri = serverUris.UiGraphqlUri;

        var body = await GetRequestTemplateAsync(nameof(CreateDataSourceSetAsync)).ConfigureAwait(false);
        var replacedBody = body.Replace("{{UserId}}", Organization.UserId.ToString());

        var requestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri)
        {
            Content = new StringContent(replacedBody, Encoding.UTF8, "application/json"),
        };
        var response = await SendRequestAsync(requestMessage, cancellationToken, true).ConfigureAwait(false);

        var result = await response.Content
            .DeserializeToAnonymousTypeAsync(new
            {
                data = new
                {
                    inbound = new
                    {
                        createDataSourceSet = (int?)null,
                    },
                },
            })
            .ConfigureAwait(false) ?? throw new InvalidOperationException("Invalid result because it is empty.");

        int? resultDataSourceSetId = result.data?.inbound?.createDataSourceSet ?? throw new InvalidOperationException("DataSourceSetId is not found in result.");

        fileSource.DataSourceSetId = resultDataSourceSetId.Value;
    }

    private void CreateFileSources(string testId)
    {
        IEnumerable<string> files = Array.Empty<string>();
        if (!string.IsNullOrWhiteSpace(Options.InputDirectoryPath))
        {
            if (!Directory.Exists(Options.InputDirectoryPath))
            {
                throw new InvalidOperationException($"Input directory '{Options.InputDirectoryPath}' does not exist.");
            }
            files = Directory.GetFiles(Options.InputDirectoryPath)
                .Where(file => !file.EndsWith(".customization.json"));
        }
        else
        {
            if (string.IsNullOrWhiteSpace(Options.InputFilePath))
            {
                throw new InvalidOperationException($"Input file '{Options.InputFilePath}' is invalid.");
            }
            files = new string[]
            {
                Options.InputFilePath
            };
        }

        if (!files.Any())
        {
            throw new InvalidOperationException("No input files found.");
        }

        this.Logger.LogInformation("There are {TotalFiles} files to be processed.", files.Count());
        FileSources = files.Select((file, index) =>
        {
            var fileNameWithoutExtension = Path.GetFileNameWithoutExtension(file);
            var sanitizedFileName = InvalidEntityTypeNameRegex.Replace(fileNameWithoutExtension, string.Empty);
            var entityType = $"testEntityx{testId}x{index}x{sanitizedFileName}";
            return new FileSource
            {
                UploadFilePath = file,
                IsExternalUploadFilePath = TestFileHelper.IsExternalTestFile(file),
                VocabularyKey = entityType,
                EntityType = entityType,
            };
        }).ToList();
    }


    private async Task<int> GetNumberOfCluesAsync(CancellationToken cancellationToken)
    {
        var counter = 0;
        string? line;

        using var streamReader = new StreamReader(TestFileHelper.GetTestFileStream(Options.InputFilePath));
        while ((line = await streamReader.ReadLineAsync().ConfigureAwait(false)) != null)
        {
            counter++;
        }

        return counter - 1; //assume header row exists
    }

    protected Stream GetUploadFileStream(FileSource fileSource)
    {
        return TestFileHelper.GetTestFileStream(fileSource.UploadFilePath);
    }

    protected async Task<HttpResponseMessage> GetDataSourceByIdAsync(FileSource fileSource, CancellationToken cancellationToken)
    {
        var serverUris = await GetServerUris(cancellationToken).ConfigureAwait(false);
        var requestUri = serverUris.UiGraphqlUri;

        var body = await GetRequestTemplateAsync(nameof(GetDataSourceByIdAsync)).ConfigureAwait(false);
        var replacedBody = body.Replace("{{DataSourceId}}", fileSource.DataSourceId.ToString());

        var requestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri)
        {
            Content = new StringContent(replacedBody, Encoding.UTF8, "application/json"),
        };

        var response = await SendRequestAsync(requestMessage, cancellationToken, true).ConfigureAwait(false);
        return response;
    }

    protected async Task AutoAnnotateAsync(FileSource fileSource, CancellationToken cancellationToken)
    {
        var serverUris = await GetServerUris(cancellationToken).ConfigureAwait(false);
        var requestUri = serverUris.UiGraphqlUri;

        var body = await GetRequestTemplateAsync(nameof(AutoAnnotateAsync)).ConfigureAwait(false);
        var replacedBody = body.Replace("{{DataSetId}}", fileSource.DataSetId.ToString())
            .Replace("{{VocabularyKey}}", fileSource.VocabularyKey)
            .Replace("{{EntityType}}", fileSource.EntityType);

        var requestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri)
        {
            Content = new StringContent(replacedBody, Encoding.UTF8, "application/json"),
        };

        var response = await SendRequestAsync(requestMessage, cancellationToken, true).ConfigureAwait(false);
    }

    protected async Task GetAnnotationIdAsync(FileSource fileSource, CancellationToken cancellationToken)
    {
        var response = await GetDataSourceByIdAsync(fileSource, cancellationToken).ConfigureAwait(false);
        var result = await response.Content
            .DeserializeToAnonymousTypeAsync(new
            {
                data = new
                {
                    inbound = new
                    {
                        dataSource = new
                        {
                            dataSets = new[]
                            {
                            new
                            {
                                annotationId = (int?)null
                            },
                            },
                        },
                    },
                },
            }).ConfigureAwait(false) ?? throw new InvalidOperationException("Invalid result because it is empty.");

        int? annotationId = result.data?.inbound?.dataSource?.dataSets?[0]?.annotationId ?? throw new InvalidOperationException("AnnotationId is not found in result.");

        fileSource.AnnotationId = annotationId.Value;
    }

    protected async Task SetAutoGeneratedOriginEntityCodeKeyAsync(FileSource fileSource, CancellationToken cancellationToken)
    {
        var serverUris = await GetServerUris(cancellationToken).ConfigureAwait(false);
        var requestUri = serverUris.UiGraphqlUri;

        var body = await GetRequestTemplateAsync(nameof(SetAutoGeneratedOriginEntityCodeKeyAsync)).ConfigureAwait(false);
        var replacedBody = body.Replace("{{AnnotationId}}", fileSource.AnnotationId.ToString());

        var requestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri)
        {
            Content = new StringContent(replacedBody, Encoding.UTF8, "application/json"),
        };
        var response = await SendRequestAsync(requestMessage, cancellationToken, true).ConfigureAwait(false);
    }

    public class CustomMappingOptions
    {

        public bool ShouldAutoGenerateOriginEntityCodeKey { get; set; } = true;

        public IEnumerable<CustomMappingRequest> MappingRequests { get; set; } = Enumerable.Empty<CustomMappingRequest>();
    }

    public class CustomMappingRequest
    {
        public string Name { get; set; }

        public string Request { get; set; }
    }
}
